package cmis440Lab1;
/**
* Program Name: CMIS440 Lab 1 Word Counter
* @author Brandon R Russell
* @Course CMIS440
* Date: Nov 15,2010
* IDE: NetBeans 6.9.1
* OS: Windows 7
* Java: JDK 1.6.0_22
*
* Program Requirements: GUI Based, include JFileChooser, use atleast 4 different
* UI controls from Chp. 14, include a menu, use a generic Map, including reading
* and/or writing to a text file, use two methods from Chp. 16, use StringBuilder
* class, and handle file related exceptions as a minimum.
*
* Program Design: I designed this program so one can, from the main form, choose
* either one or multiple text files, or an entire directory that contains the
* text files, and the program will determine how many unique words are found in
* the files and give a count of how often the words were used. It will display
* this information on the main form and also to 'output.txt'. There are options
* on where one can decide to make the search case sensitive and also to change
* the delimiter. When program starts it will create a separate thread for each
* text file being processed and will save this information in individual
* FileResult objects and also into the shared TotalResults object.
*
* Things you what me to know before I grade your work: I used the NetBeans
* Graphic designer to create the GUI portion of this program. Also, for some
* reason after my SwingWorker Thread, ThreadControl class, is done it hangs for
* a few seconds before the GUI actually indicates it is done. I did some
* exhaustive research on this, but could not determine a fix. Also, on the
* ThreadControl class in the doInBackground method I did not throw my exceptions
* , rather I caught them right there. I am able to throw them in the constructor
* of this class and they are caught in the EDT, but for some reason this is not
* the case for the doInBackground method of this SwingWorker. I initially found
* through research that it was because I was not calling get() in my done method
* , however I tried this and it did not work. The exceptions are being handled,
* however, just not in the way I wanted them to. At this point, however, I just
* don't have enough time to figure it out.
*/

import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.JOptionPane;
import java.awt.Cursor;
import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.regex.*;


/** This is the main window of operation for the entire program. The purpose of
* this class is to create a GUI Interface that will allow the user to make
* selections of text files for the purpose of finding the unique words used and
* the count of these words.
*|----------------------------------------------------------------------------|
*|                                CRC: LabMainWindow                          |
*|----------------------------------------------------------------------------|
*|Creates GUI Interface                                                       |
*|Initialize ThreadControl object/ Start File Processing       ThreadControl  |
*|----------------------------------------------------------------------------|
*
* @TheCs Cohesion - All methods in this class work together on similar task.
* Completeness - Completely creates/runs a ThreadControl object and provides
*                output of file information
* Convenience - There are sufficient methods and variables to complete the
*                required task.
* Clarity - The methods and variables are distinguishable and work in a
*           uniform manner to provide clarity to other programmers.
* Consistency - All names,parameters ,return values , and behaviors follow
*               the same basic rules.
*/



        
public class LabMainWindow extends javax.swing.JFrame
        implements PropertyChangeListener {

    /** Creates new form LabMainWindow */
    public LabMainWindow() {
        initComponents();
    }


    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */


    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlOutput = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtOutput = new javax.swing.JTextArea();
        pnlInput = new javax.swing.JPanel();
        fileDirChooser = new javax.swing.JFileChooser();
        pnlOptions = new javax.swing.JPanel();
        chkCaseSensitive = new javax.swing.JCheckBox();
        lblDelimiter = new javax.swing.JLabel();
        txtDelimiter = new javax.swing.JTextField();
        pnlAction = new javax.swing.JPanel();
        pBarFileProcessing = new javax.swing.JProgressBar();
        btnStartProcess = new javax.swing.JButton();
        mnuMain = new javax.swing.JMenuBar();
        mnuFile = new javax.swing.JMenu();
        mnuStart = new javax.swing.JMenuItem();
        mnuExit = new javax.swing.JMenuItem();
        mnuEdit = new javax.swing.JMenu();
        mnuCopy = new javax.swing.JMenuItem();
        mnuHelp = new javax.swing.JMenu();
        mnuInstructions = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CMIS440 Lab 1 Word Counter");
        setBackground(javax.swing.UIManager.getDefaults().getColor("Nb.Desktop.background"));

        pnlOutput.setBorder(javax.swing.BorderFactory.createTitledBorder("Output:"));

        txtOutput.setColumns(40);
        txtOutput.setEditable(false);
        txtOutput.setFont(new java.awt.Font("Courier New", 0, 13)); // NOI18N
        txtOutput.setRows(5);
        txtOutput.setToolTipText("program output will be here");
        jScrollPane1.setViewportView(txtOutput);

        javax.swing.GroupLayout pnlOutputLayout = new javax.swing.GroupLayout(pnlOutput);
        pnlOutput.setLayout(pnlOutputLayout);
        pnlOutputLayout.setHorizontalGroup(
            pnlOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOutputLayout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 572, Short.MAX_VALUE)
                .addGap(20, 20, 20))
        );
        pnlOutputLayout.setVerticalGroup(
            pnlOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOutputLayout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 408, Short.MAX_VALUE)
                .addContainerGap())
        );

        pnlInput.setBorder(javax.swing.BorderFactory.createTitledBorder("Input:"));

        fileDirChooser.setBackground(javax.swing.UIManager.getDefaults().getColor("FileChooser.listViewBackground"));
        fileDirChooser.setControlButtonsAreShown(false);
        fileDirChooser.setDialogTitle("Pick one or more Text Files to process");
        fileDirChooser.setFileFilter(new FileNameExtensionFilter("Text Files", "txt"));
        fileDirChooser.setFileSelectionMode(javax.swing.JFileChooser.FILES_AND_DIRECTORIES);
        fileDirChooser.setToolTipText("Select one or more text files or an entire directory");
        fileDirChooser.setBorder(null);
        fileDirChooser.setMultiSelectionEnabled(true);
        fileDirChooser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fileDirChooserActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlInputLayout = new javax.swing.GroupLayout(pnlInput);
        pnlInput.setLayout(pnlInputLayout);
        pnlInputLayout.setHorizontalGroup(
            pnlInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlInputLayout.createSequentialGroup()
                .addComponent(fileDirChooser, javax.swing.GroupLayout.PREFERRED_SIZE, 386, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(88, Short.MAX_VALUE))
        );
        pnlInputLayout.setVerticalGroup(
            pnlInputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlInputLayout.createSequentialGroup()
                .addComponent(fileDirChooser, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(36, Short.MAX_VALUE))
        );

        pnlOptions.setBorder(javax.swing.BorderFactory.createTitledBorder("Options"));

        chkCaseSensitive.setText("case sensitive");
        chkCaseSensitive.setToolTipText("Distinguish between case sensitive words?");
        chkCaseSensitive.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chkCaseSensitiveActionPerformed(evt);
            }
        });

        lblDelimiter.setText("Set Delimiter *Default is a Space");

        javax.swing.GroupLayout pnlOptionsLayout = new javax.swing.GroupLayout(pnlOptions);
        pnlOptions.setLayout(pnlOptionsLayout);
        pnlOptionsLayout.setHorizontalGroup(
            pnlOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOptionsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(chkCaseSensitive)
                    .addComponent(lblDelimiter, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(txtDelimiter))
                .addContainerGap(47, Short.MAX_VALUE))
        );
        pnlOptionsLayout.setVerticalGroup(
            pnlOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOptionsLayout.createSequentialGroup()
                .addComponent(chkCaseSensitive)
                .addGap(18, 18, 18)
                .addComponent(lblDelimiter)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(txtDelimiter, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(63, Short.MAX_VALUE))
        );

        pnlAction.setBorder(javax.swing.BorderFactory.createTitledBorder("Action"));

        pBarFileProcessing.setToolTipText("Progress of file processing");
        pBarFileProcessing.setStringPainted(true);

        btnStartProcess.setText("Start");
        btnStartProcess.setToolTipText("Start processing selected text files");
        btnStartProcess.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStartProcessActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlActionLayout = new javax.swing.GroupLayout(pnlAction);
        pnlAction.setLayout(pnlActionLayout);
        pnlActionLayout.setHorizontalGroup(
            pnlActionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pnlActionLayout.createSequentialGroup()
                .addContainerGap(41, Short.MAX_VALUE)
                .addGroup(pnlActionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlActionLayout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(btnStartProcess))
                    .addComponent(pBarFileProcessing, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(33, 33, 33))
        );
        pnlActionLayout.setVerticalGroup(
            pnlActionLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlActionLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnStartProcess)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pBarFileProcessing, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(79, Short.MAX_VALUE))
        );

        mnuMain.setForeground(javax.swing.UIManager.getDefaults().getColor("MenuBar.background"));

        mnuFile.setText("File");

        mnuStart.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        mnuStart.setText("Start");
        mnuStart.setToolTipText("Start processing selected text files");
        mnuStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuStartActionPerformed(evt);
            }
        });
        mnuFile.add(mnuStart);

        mnuExit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_X, java.awt.event.InputEvent.CTRL_MASK));
        mnuExit.setText("Exit");
        mnuExit.setToolTipText("Exit Program");
        mnuExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuExitActionPerformed(evt);
            }
        });
        mnuFile.add(mnuExit);

        mnuMain.add(mnuFile);

        mnuEdit.setText("Edit");

        mnuCopy.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.CTRL_MASK));
        mnuCopy.setText("Copy");
        mnuCopy.setToolTipText("Copy text from output area");
        mnuCopy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuCopyActionPerformed(evt);
            }
        });
        mnuEdit.add(mnuCopy);

        mnuMain.add(mnuEdit);

        mnuHelp.setText("Help");
        mnuHelp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuHelpActionPerformed(evt);
            }
        });

        mnuInstructions.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.CTRL_MASK));
        mnuInstructions.setText("Instructions");
        mnuInstructions.setToolTipText("Learn how to use the program");
        mnuInstructions.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuInstructionsActionPerformed(evt);
            }
        });
        mnuHelp.add(mnuInstructions);

        mnuMain.add(mnuHelp);

        setJMenuBar(mnuMain);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(10, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(pnlInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pnlOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pnlAction, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pnlOutput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pnlOutput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pnlInput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pnlOptions, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pnlAction, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {pnlInput, pnlOutput});

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void fileDirChooserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileDirChooserActionPerformed

    }//GEN-LAST:event_fileDirChooserActionPerformed


    /** Calls the startProcessingFiles method to begin the file processing.
    * @TheCs Cohesion - Call startProcessingFiles method; begin file processing.
    * Completeness - Completely calls the startProcessingFiles method and begins
    *                the file processing.
    * Convenience - Simply calls the startProcessingFiles method and begins the
    *               file processing.
    * Clarity - It is simple to understand that this calls the startProcessingFiles
    *           method to begin the file processing.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void btnStartProcessActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnStartProcessActionPerformed
        startProcessingFiles();
    }//GEN-LAST:event_btnStartProcessActionPerformed

    private void mnuHelpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuHelpActionPerformed

    }//GEN-LAST:event_mnuHelpActionPerformed
    /** Opens a JOptionPane Dialog to give simple instructions on usage.
    * @TheCs Cohesion - Open JOptionPane Dialog; give instructions on usage.
    * Completeness - Completely opens a JOptionPane Dialog to give simple
    *                instructions on program usage.
    * Convenience - Simply opens a JOptionPane Dialog; gives simple instructions
    *               on program usage.
    * Clarity - It is simple to understand that this opens a JOptionPane Dialog
    *           to give simple instructions on usage of the program.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void mnuInstructionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuInstructionsActionPerformed
    String instructionMessage = "1) Select one or more files, or an "
        + "entire directory, from the file chooser below.\n"
        + "2) Select options from the option panel below.\n"
        + "3) Select Start from Menu or click the Start button.\n"
        + "4) Output sent to Output Text Area and output.txt in application"
        + " directory.";

    JOptionPane.showMessageDialog(null, instructionMessage,
        "Instructions", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_mnuInstructionsActionPerformed

    private void chkCaseSensitiveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chkCaseSensitiveActionPerformed

    }//GEN-LAST:event_chkCaseSensitiveActionPerformed
    /** Allows user to copy the entire text from the txtOutput TextArea.
    * @TheCs Cohesion - Allow user to copy the text from the txtOutput TextArea.
    * Completeness - Completely lets one copy all the text from the txtOutput
    *                TextArea.
    * Convenience - Simply allows one to copy all the text from the txtOutput
    *               TextArea
    * Clarity - It is simple to understand that this allows one to copy all the
    *           text from the txtOutput TextArea.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void mnuCopyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuCopyActionPerformed
        try{
            Clipboard system = Toolkit.getDefaultToolkit().getSystemClipboard();
            StringSelection txtOutputSel =
                    new StringSelection(txtOutput.getText());
            system.setContents(txtOutputSel, txtOutputSel);

        }catch(Exception exception){
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "Exception Thrown on copy action",
                    JOptionPane.ERROR_MESSAGE);
        }

    }//GEN-LAST:event_mnuCopyActionPerformed
    /** Properly exits the program.
    * @TheCs Cohesion - Properly exits the program.
    * Completeness - Completely exits the program.
    * Convenience - Simply exits the program.
    * Clarity - It is simple to understand that this exits the program.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void mnuExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_mnuExitActionPerformed
    /** Calls the startProcessingFiles method to begin the file processing.
    * @TheCs Cohesion - Call startProcessingFiles method; begin file processing.
    * Completeness - Completely calls the startProcessingFiles method and begins
    *                the file processing.
    * Convenience - Simply calls the startProcessingFiles method and begins the
    *               file processing.
    * Clarity - It is simple to understand that this calls the startProcessingFiles
    *           method to begin the file processing.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    private void mnuStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuStartActionPerformed
        startProcessingFiles();
    }//GEN-LAST:event_mnuStartActionPerformed

    /** Main method that starts the program by making the GUI visible.
    * @TheCs Cohesion - Starts the program by making the GUI visible.
    * Completeness - Completely makes the GUI visible.
    * Convenience - Simply makes the GUI visible.
    * Clarity - It is simple to understand that this makes the GUI visible.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    *
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        
        javax.swing.SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                
                new LabMainWindow().setVisible(true);
            }
        });
    }
    /** Creates ThreadControl object to begin file processing.
    * This method disables the Start button, Start Menu Item, turns the cursor
    * into a working icon, gets the case sensitive check and also the delimiter,
    * and then creates a ThreadControl object and executes it on a new
    * SwingWorker worker thread so as not to freeze the GUI during processing.
    * @TheCs Cohesion - Creates ThreadControl object to begin file processing.
    * Completeness - Completely creates ThreadControl object to begin
    *                file processing.
    * Convenience - Simply creates ThreadControl object to begin file processing
    * Clarity - It is simple to understand that this creates ThreadControl
    *           object to begin file processing.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    * @precondition Must have at least one text file selected for processing.
    * @throws exception if at least one file is not chosen.
    * @exception General exception capture
    */
    private void startProcessingFiles(){
        try{
            filterOutputFileName();
            setControlsToWait();
            if (fileDirChooser.getSelectedFiles().length <= 0){
                throw new Exception("Must select atleast one file");
            }
            String myWordDelimiter = "\\p{Zs}"; //Default delimiter; a space
            Boolean myCaseSensitiveCheck = false;
            if (!txtDelimiter.getText().isEmpty()){
                myWordDelimiter = txtDelimiter.getText();
            }
            if (chkCaseSensitive.isSelected()){
                myCaseSensitiveCheck = true;
            }
            String[] selectedFileNames =
                    new String[fileDirChooser.getSelectedFiles().length];
            int counter = 0;
            for (File element: fileDirChooser.getSelectedFiles()){
                selectedFileNames[counter] = element.toString();
                counter++;
            }
            ThreadControl myThreadControl = new ThreadControl(selectedFileNames,
                    myWordDelimiter, myCaseSensitiveCheck);
            myThreadControl.addPropertyChangeListener(this);
            myThreadControl.execute(); //Begin Worker Thread

        }catch (Exception exception) {
            setControlsToActive();
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "Exception Thrown on Start Process",
                    JOptionPane.ERROR_MESSAGE);
        }
    }
    /** Detects progress of file processing from ThreadControl object.
    * Basically this will determine if the setProgress has been called from
    * the ThreadControl object and will increment the progress bar if so.
    * Will also determine if ThreadControl is done, and if so will call
    * displayOutputFile.
    * @TheCs Cohesion - Detects progress of file processing from ThreadControl
    *                   object.
    * Completeness - Completely detects progress of file processing from
    *                ThreadControl object.
    * Convenience - Simply detects progress of file processing from
    *               ThreadControl object.
    * Clarity - It is simple to understand that this detects progress of file
    *           processing from ThreadControl object.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    * @param PropertyChangeEvent Determine progress of ThreadControl
    */
    public void propertyChange(PropertyChangeEvent evt){
        if ("progress".equals(evt.getPropertyName())){
            int progress = (Integer) evt.getNewValue();
            pBarFileProcessing.setValue(progress);
            if (progress == 95){
                displayOutputFile();
                pBarFileProcessing.setValue(100);
            }
        }
    }
    /** Reads in and displays output text file to txtOutput TextArea
    * @TheCs Cohesion - Reads in/displays output text file to txtOutput TextArea
    * Completeness - Completely reads in and displays output text file to
    *                txtOutput TextArea
    * Convenience - Simply reads in and displays output text file to
    *               txtOutput TextArea
    * Clarity - It is simple to understand that this reads in and displays
    *           output text file to txtOutput TextArea
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    *
    * @exception  FileNotFound Exception if the output file is not found
    * @exception  IOException for an I/O Exception that may occur w/ output file.
    * @exception  Exception for general exception captures
    */
    public void displayOutputFile(){
        BufferedReader readOutputFile = null;
        try{
            String tempFileInfoHolder = "";
            readOutputFile = new BufferedReader(
                    new FileReader(outputFileName));
            while(readOutputFile.ready()){
                tempFileInfoHolder += readOutputFile.readLine() + "\n";
            }
            txtOutput.setText(tempFileInfoHolder);
        }catch( FileNotFoundException exception){
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "Output file not found for reading",
                    JOptionPane.ERROR_MESSAGE);
        }catch(IOException exception){
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "I/O Exception Thrown on File Output",
                    JOptionPane.ERROR_MESSAGE);
        }catch(Exception exception){
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "Unknown Exception Thrown on File Output",
                    JOptionPane.ERROR_MESSAGE);
        }finally{
            try{
                if (readOutputFile != null){
                    readOutputFile.close();
                }
                setControlsToActive();
            }catch(IOException exception){
                JOptionPane.showMessageDialog(null,exception.getMessage(),
                        "I/O Exception Thrown on File Output",
                        JOptionPane.ERROR_MESSAGE);
            }

        }
    }
    /** Disables Start Menu, Start Button,and sets cursor to wait icon.
    * @TheCs Cohesion - Disables Start Menu/Start Button/sets cursor to wait.
    * Completeness - Completely disables Start Menu, Start Button,and sets
    *                cursor to wait icon.
    * Convenience - Simply disables Start Menu, Start Button,and sets cursor
    *               to wait icon.
    * Clarity - It is simple to understand that this Disables Start Menu,
    *           Start Button,and sets cursor to wait icon.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    public void setControlsToWait(){
        btnStartProcess.setEnabled(false);
        mnuStart.setEnabled(false);
        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
    }
    /** Enables Start Menu, Start Button,and sets cursor to normal icon.
    * @TheCs Cohesion - Enables Start Menu/Start Button/sets cursor to normal.
    * Completeness - Completely enables Start Menu, Start Button,and sets
    *                cursor to normal icon.
    * Convenience - Simply enables Start Menu, Start Button,and sets cursor
    *               to normal icon.
    * Clarity - It is simple to understand that this enables Start Menu,
    *           Start Button,and sets cursor to normal icon.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    */
    public void setControlsToActive(){
        btnStartProcess.setEnabled(true);
        mnuStart.setEnabled(true);
        setCursor(null);
        Toolkit.getDefaultToolkit().beep();
    }
    /** Remove 'file:/' , if filename present(remove it), add output.txt to end
    * @TheCs Cohesion - Removes 'file:/' from the beginning, if filename is
    *                   present then remove it, and finally add output.txt
    *                   to the end.
    * Completeness - Completely removes 'file:/' from the beginning, if filename
    *                   is present then remove it, and finally add output.txt
    *                   to the end.
    * Convenience - Simply removes 'file:/' from the beginning, if filename is
    *                   present then remove it, and finally add output.txt
    *                   to the end.
    * Clarity - It is simple to understand that this Removes 'file:/' from the
    *           beginning, if filename is present then remove it, and finally
    *           add output.txt to the end.
    * Consistency - It uses the same syntax rules as the rest of the class and
    *               continues to use proper casing and indentation.
    * @exception General exception capture
    */
    public void filterOutputFileName(){
        try{
            if (outputFileName.contains("file:/")){
                outputFileName = outputFileName.substring(outputFileName
                        .indexOf("/") + 1);
            }
            String extRegex = "(.*/).*[^/]\\.\\p{Alpha}*";
            Pattern pattern = Pattern.compile(extRegex);
            Matcher matcher = pattern.matcher(outputFileName);
            if (matcher.find()){
                outputFileName = matcher.group(1);
            }

            if (!outputFileName.endsWith("/")){
                outputFileName = outputFileName + "/";
            }
            outputFileName += "output.txt";
        }catch (Exception exception){
            JOptionPane.showMessageDialog(null,exception.getMessage(),
                    "Exception Thrown on Filename filter process",
                    JOptionPane.ERROR_MESSAGE);
        }
    }

    /**outputFileName is Static because it is used both in this class and the
    *  ThreadControl class. Also it is not declared in the same area as the
    * other variables because these are auto-generated by the NetBeans GUI
    * designer. Also the class.getProtectionDomain().getCodeSource().getLocation
    * is used to determine the directory where the application resides.
    */
    public static String outputFileName = LabMainWindow.class.
            getProtectionDomain().getCodeSource().getLocation().toString();

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnStartProcess;
    private javax.swing.JCheckBox chkCaseSensitive;
    private javax.swing.JFileChooser fileDirChooser;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lblDelimiter;
    private javax.swing.JMenuItem mnuCopy;
    private javax.swing.JMenu mnuEdit;
    private javax.swing.JMenuItem mnuExit;
    private javax.swing.JMenu mnuFile;
    private javax.swing.JMenu mnuHelp;
    private javax.swing.JMenuItem mnuInstructions;
    private javax.swing.JMenuBar mnuMain;
    private javax.swing.JMenuItem mnuStart;
    private javax.swing.JProgressBar pBarFileProcessing;
    private javax.swing.JPanel pnlAction;
    private javax.swing.JPanel pnlInput;
    private javax.swing.JPanel pnlOptions;
    private javax.swing.JPanel pnlOutput;
    private javax.swing.JTextField txtDelimiter;
    private javax.swing.JTextArea txtOutput;
    // End of variables declaration//GEN-END:variables


}
